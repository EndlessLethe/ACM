这道题其实是这套题的C题扩展，依然可以是穷举排列（用一个k++%m来生成）看什么时候可以整除。不过C恰好没有爆unsigned long long。
我们只能使用数组来储存（我们还是可以每次根据k来算出对应的序列，然而k会爆long long）。
所以这道题我们选择用bfs来生成排列。bfs的层数可以用struct中的lay来记录。（当然这样会对空间造成很大的浪费，因为每次的序列都被压到了栈里。更好的还是重写数组k来计算？）
最后我被有一个细节坑惨，如果读入时是arr[i] -= '0'这样的话，要对arr做一个排序。不然有可能搜索到的是990而不是110。

这道题有三个细节：
1）如何在不用k的情况下生成只由M构成的序列。

2）大数取模：核心公式是 for (int i = 0; i < len; i++) tem = (tem*x+c[i])%n

3）剪枝
这道题又可以利用：if a%b = b%n,则有(a*x+c)%n = (b*x+c)%n 来剪枝  （b是a的某一个添加了后缀的串）
c是我们按顺序生成的后缀，是一定相同的M个。而x是进制数，也相同。所以当a,b相同时，情况是相同的。
vis数组的大小显然不会超过N，也就是5000.我看网上有的博文说得云里雾里的，什么抽屉呀，鸽巢呀，对于这道题来说只需要知道，开vis[5010]就够了。

其他常用的模运算公式：
(a + b) % p = (a % p + b % p) % p
(a - b) % p = (a % p - b % p) % p
(a * b) % p = ((a % p) * (b % p)) % p
(a ^ b) % p = ((a % p) ^ b) % p
